{"version":3,"file":"dedupe.min.js","sources":["../src/dedupe.ts"],"sourcesContent":["import { Event, EventProcessor, Exception, Hub, Integration, StackFrame } from '@sentry/types';\n\n/** Deduplication filter */\nexport class Dedupe implements Integration {\n  /**\n   * @inheritDoc\n   */\n  private _previousEvent?: Event;\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Dedupe.id;\n\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Dedupe';\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    addGlobalEventProcessor((currentEvent: Event) => {\n      const self = getCurrentHub().getIntegration(Dedupe);\n      if (self) {\n        // Juuust in case something goes wrong\n        try {\n          if (self._shouldDropEvent(currentEvent, self._previousEvent)) {\n            return null;\n          }\n        } catch (_oO) {\n          return (self._previousEvent = currentEvent);\n        }\n\n        return (self._previousEvent = currentEvent);\n      }\n      return currentEvent;\n    });\n  }\n\n  /** JSDoc */\n  private _shouldDropEvent(currentEvent: Event, previousEvent?: Event): boolean {\n    if (!previousEvent) {\n      return false;\n    }\n\n    if (this._isSameMessageEvent(currentEvent, previousEvent)) {\n      return true;\n    }\n\n    if (this._isSameExceptionEvent(currentEvent, previousEvent)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /** JSDoc */\n  private _isSameMessageEvent(currentEvent: Event, previousEvent: Event): boolean {\n    const currentMessage = currentEvent.message;\n    const previousMessage = previousEvent.message;\n\n    // If no event has a message, they were both exceptions, so bail out\n    if (!currentMessage && !previousMessage) {\n      return false;\n    }\n\n    // If only one event has a stacktrace, but not the other one, they are not the same\n    if ((currentMessage && !previousMessage) || (!currentMessage && previousMessage)) {\n      return false;\n    }\n\n    if (currentMessage !== previousMessage) {\n      return false;\n    }\n\n    if (!this._isSameFingerprint(currentEvent, previousEvent)) {\n      return false;\n    }\n\n    if (!this._isSameStacktrace(currentEvent, previousEvent)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /** JSDoc */\n  private _getFramesFromEvent(event: Event): StackFrame[] | undefined {\n    const exception = event.exception;\n\n    if (exception) {\n      try {\n        // @ts-ignore\n        return exception.values[0].stacktrace.frames;\n      } catch (_oO) {\n        return undefined;\n      }\n    } else if (event.stacktrace) {\n      return event.stacktrace.frames;\n    }\n    return undefined;\n  }\n\n  /** JSDoc */\n  private _isSameStacktrace(currentEvent: Event, previousEvent: Event): boolean {\n    let currentFrames = this._getFramesFromEvent(currentEvent);\n    let previousFrames = this._getFramesFromEvent(previousEvent);\n\n    // If no event has a fingerprint, they are assumed to be the same\n    if (!currentFrames && !previousFrames) {\n      return true;\n    }\n\n    // If only one event has a stacktrace, but not the other one, they are not the same\n    if ((currentFrames && !previousFrames) || (!currentFrames && previousFrames)) {\n      return false;\n    }\n\n    currentFrames = currentFrames as StackFrame[];\n    previousFrames = previousFrames as StackFrame[];\n\n    // If number of frames differ, they are not the same\n    if (previousFrames.length !== currentFrames.length) {\n      return false;\n    }\n\n    // Otherwise, compare the two\n    for (let i = 0; i < previousFrames.length; i++) {\n      const frameA = previousFrames[i];\n      const frameB = currentFrames[i];\n\n      if (\n        frameA.filename !== frameB.filename ||\n        frameA.lineno !== frameB.lineno ||\n        frameA.colno !== frameB.colno ||\n        frameA.function !== frameB.function\n      ) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /** JSDoc */\n  private _getExceptionFromEvent(event: Event): Exception | undefined {\n    return event.exception && event.exception.values && event.exception.values[0];\n  }\n\n  /** JSDoc */\n  private _isSameExceptionEvent(currentEvent: Event, previousEvent: Event): boolean {\n    const previousException = this._getExceptionFromEvent(previousEvent);\n    const currentException = this._getExceptionFromEvent(currentEvent);\n\n    if (!previousException || !currentException) {\n      return false;\n    }\n\n    if (previousException.type !== currentException.type || previousException.value !== currentException.value) {\n      return false;\n    }\n\n    if (!this._isSameFingerprint(currentEvent, previousEvent)) {\n      return false;\n    }\n\n    if (!this._isSameStacktrace(currentEvent, previousEvent)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /** JSDoc */\n  private _isSameFingerprint(currentEvent: Event, previousEvent: Event): boolean {\n    let currentFingerprint = currentEvent.fingerprint;\n    let previousFingerprint = previousEvent.fingerprint;\n\n    // If no event has a fingerprint, they are assumed to be the same\n    if (!currentFingerprint && !previousFingerprint) {\n      return true;\n    }\n\n    // If only one event has a fingerprint, but not the other one, they are not the same\n    if ((currentFingerprint && !previousFingerprint) || (!currentFingerprint && previousFingerprint)) {\n      return false;\n    }\n\n    currentFingerprint = currentFingerprint as string[];\n    previousFingerprint = previousFingerprint as string[];\n\n    // Otherwise, compare the two\n    try {\n      return !!(currentFingerprint.join('') === previousFingerprint.join(''));\n    } catch (_oO) {\n      return false;\n    }\n  }\n}\n"],"names":["this","Dedupe","id","addGlobalEventProcessor","getCurrentHub","currentEvent","self","getIntegration","_shouldDropEvent","_previousEvent","_oO","previousEvent","_isSameMessageEvent","_isSameExceptionEvent","currentMessage","message","previousMessage","_isSameFingerprint","_isSameStacktrace","event","exception","values","stacktrace","frames","currentFrames","_getFramesFromEvent","previousFrames","length","i","frameA","frameB","filename","lineno","colno","function","previousException","_getExceptionFromEvent","currentException","type","value","currentFingerprint","fingerprint","previousFingerprint","join"],"mappings":"uEAGA,iBAAA,aASSA,UAAeC,EAAOC,GA4L/B,OAlLSD,sBAAP,SAAiBE,EAA6DC,GAC5ED,EAAwB,SAACE,GACvB,IAAMC,EAAOF,IAAgBG,eAAeN,GAC5C,GAAIK,EAAM,CAER,IACE,GAAIA,EAAKE,iBAAiBH,EAAcC,EAAKG,gBAC3C,OAAO,KAET,MAAOC,GACP,OAAQJ,EAAKG,eAAiBJ,EAGhC,OAAQC,EAAKG,eAAiBJ,EAEhC,OAAOA,KAKHJ,6BAAR,SAAyBI,EAAqBM,GAC5C,QAAKA,MAIDX,KAAKY,oBAAoBP,EAAcM,MAIvCX,KAAKa,sBAAsBR,EAAcM,KAQvCV,gCAAR,SAA4BI,EAAqBM,GAC/C,IAAMG,EAAiBT,EAAaU,QAC9BC,EAAkBL,EAAcI,QAGtC,SAAKD,IAAmBE,OAKnBF,IAAmBE,IAAsBF,GAAkBE,KAI5DF,IAAmBE,MAIlBhB,KAAKiB,mBAAmBZ,EAAcM,MAItCX,KAAKkB,kBAAkBb,EAAcM,OAQpCV,gCAAR,SAA4BkB,GAC1B,IAAMC,EAAYD,EAAMC,UAExB,GAAIA,EACF,IAEE,OAAOA,EAAUC,OAAO,GAAGC,WAAWC,OACtC,MAAOb,GACP,YAEG,GAAIS,EAAMG,WACf,OAAOH,EAAMG,WAAWC,QAMpBtB,8BAAR,SAA0BI,EAAqBM,GAC7C,IAAIa,EAAgBxB,KAAKyB,oBAAoBpB,GACzCqB,EAAiB1B,KAAKyB,oBAAoBd,GAG9C,IAAKa,IAAkBE,EACrB,OAAO,EAIT,GAAKF,IAAkBE,IAAqBF,GAAiBE,EAC3D,OAAO,EAOT,GAJAF,EAAgBA,GAChBE,EAAiBA,GAGEC,SAAWH,EAAcG,OAC1C,OAAO,EAIT,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAeC,OAAQC,IAAK,CAC9C,IAAMC,EAASH,EAAeE,GACxBE,EAASN,EAAcI,GAE7B,GACEC,EAAOE,WAAaD,EAAOC,UAC3BF,EAAOG,SAAWF,EAAOE,QACzBH,EAAOI,QAAUH,EAAOG,OACxBJ,EAAOK,WAAaJ,EAAOI,SAE3B,OAAO,EAIX,OAAO,GAIDjC,mCAAR,SAA+BkB,GAC7B,OAAOA,EAAMC,WAAaD,EAAMC,UAAUC,QAAUF,EAAMC,UAAUC,OAAO,IAIrEpB,kCAAR,SAA8BI,EAAqBM,GACjD,IAAMwB,EAAoBnC,KAAKoC,uBAAuBzB,GAChD0B,EAAmBrC,KAAKoC,uBAAuB/B,GAErD,SAAK8B,IAAsBE,KAIvBF,EAAkBG,OAASD,EAAiBC,MAAQH,EAAkBI,QAAUF,EAAiBE,UAIhGvC,KAAKiB,mBAAmBZ,EAAcM,MAItCX,KAAKkB,kBAAkBb,EAAcM,MAQpCV,+BAAR,SAA2BI,EAAqBM,GAC9C,IAAI6B,EAAqBnC,EAAaoC,YAClCC,EAAsB/B,EAAc8B,YAGxC,IAAKD,IAAuBE,EAC1B,OAAO,EAIT,GAAKF,IAAuBE,IAA0BF,GAAsBE,EAC1E,OAAO,EAGTF,EAAqBA,EACrBE,EAAsBA,EAGtB,IACE,QAAUF,EAAmBG,KAAK,MAAQD,EAAoBC,KAAK,KACnE,MAAOjC,GACP,OAAO,IApLGT,KAAa"}